---
title: "Bootstrap aggregation (bagging)"
author: "Jaime Davila"
date: "4/22/2024"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
library(tidyverse)
library(tidymodels)
library(dslabs)
library(rpart.plot)
tidymodels_prefer()
```


# Maximal classification trees

We will be considering the presidential polls dataset for the 2008 election (Obama vs McCain) and creating our testing/training dataset

```{r echo=TRUE}
library(dslabs)
data("polls_2008")
polls_2008_tbl <- tibble(polls_2008)
polls_2008_tbl

set.seed(12345)
poll_split <- initial_split(polls_2008_tbl)
poll_train_tbl <- training(poll_split)
poll_test_tbl <- testing(poll_split)
```

After this we will be creating a couple of auxiliary functions:

* `create_rtree`: fits a regression tree to `train_tbl` with a predefined complexity parameter `cp`.
* `calc_rmse`: calculates the rmse for `model` on `test_tbl`.
* `plot_model`: depicts the trends of the model using the testing dataset

```{r echo=TRUE}
create_rtree <- function(train_tbl, cp) {
  # Set up the model, recipe and workflow
  poll_model <-
  decision_tree(cost_complexity=cp) |>
  set_mode("regression") |>
  set_engine("rpart")
  poll_recipe <- recipe(margin ~ day, data=train_tbl)
  poll_wflow <- workflow() |>
    add_recipe(poll_recipe) |>
    add_model(poll_model) 
  # Fit the worfklow using the training dataset  
  fit(poll_wflow, train_tbl)
}

calc_rmse <- function(model, test_tbl) {
  augment(model, test_tbl) |>
    rmse(margin, .pred) |> 
    pull(.estimate)
}

plot_model <- function(model, test_tbl) {
  augment(model, test_tbl) |>
    ggplot()+
    geom_point(aes(day,margin))+
    geom_step(aes(day,.pred), col="red")
}
```

And we will be testing this functions using **maximal classification trees**, which are trees for which the complexity parameter is 0. Notice that for this type of tree, usually the other default parameters of `rpart` (e.g. `tree_depth` or `min_n`) are the ones responsible for the tree not having a node for each observation.

```{r}
rtree_model <- create_rtree(poll_train_tbl, 0) 
plot_model(rtree_model, poll_test_tbl)
calc_rmse(rtree_model, poll_test_tbl)

```

1. Using `poll_train_tbl`, create 3 different training datasets.  Fit maximal regression trees to each of them. Using `poll_test_tbl` plot the models and calculate the rmse for each of them. Are the results very different depending on the training dataset used?

```{r echo=TRUE}
set.seed(12345)
```

```{r}
poll_split_1 <- initial_split(poll_train_tbl)
poll_train1_tbl <- training(poll_split_1)
rtree1_model <- create_rtree(poll_train1_tbl, 0) 
```

```{r}
poll_split_2 <- initial_split(poll_train_tbl)
poll_train2_tbl <- training(poll_split_2)
rtree2_model <- create_rtree(poll_train2_tbl, 0) 
```

```{r}
poll_split_3 <- initial_split(poll_train_tbl)
poll_train3_tbl <- training(poll_split_3)
rtree3_model <- create_rtree(poll_train3_tbl, 0) 
```

```{r}
library(gridExtra)
gg1 <- plot_model(rtree1_model, poll_test_tbl)
gg2 <- plot_model(rtree2_model, poll_test_tbl)
gg3 <- plot_model(rtree3_model, poll_test_tbl)
grid.arrange(gg1, gg2, gg3)

calc_rmse(rtree1_model, poll_test_tbl)
calc_rmse(rtree2_model, poll_test_tbl)
calc_rmse(rtree3_model, poll_test_tbl)
```

2. Apply the previous 3 models to `poll_test_tbl` and create a new column `.pred` with the average of the 3 models. Plot the average and calculate the rmse. Are the results an improvement over the model at the beginning of this section?

```{r}
results_tbl <- augment(rtree1_model, poll_test_tbl) 
results_tbl <- augment(rtree2_model, results_tbl) 
results_tbl <- augment(rtree3_model, results_tbl) 

# Also can be done as:
results_tbl <- augment(rtree1_model, poll_test_tbl) %>%
  augment(rtree2_model, .) %>%
  augment(rtree3_model, .)

results_tbl <-  results_tbl |>
  mutate(.pred = (.pred...1+.pred...3+.pred...5)/3)

ggplot(results_tbl)+
    geom_point(aes(day,margin))+
    geom_step(aes(day,.pred), col="red")

rmse(results_tbl,margin, .pred) 
```

# Bagging models from scratch

Bootstrap aggregation or bagging is based on the following two key ideas:

* Maximal trees are very sensitive to their training dataset. Slightly different training datasets can result in very different trees.
 
* If we have $n$ *independent* variables $X_1, \dots, X_n$ with a standard deviation $\sigma$, the standard deviation of their average is $\frac {\sigma} {\sqrt n}$. This implies that we can control the error of a collection of maximal trees by considering their average (this principle is sometimes called "the wisdom of the crowd")

In bagging we average the results of multiple maximal trees that are trained on slightly different bootstrapped training datasets. Let's start by creating a function `create_bag_rtree` that creates a bootstrap of our training dataset `train_tbl`, fits a maximal tree and outputs the results of that tree evaluated on our testing dataset `test_tbl`

```{r}
create_bag_rtree <- function(id, train_tbl, test_tbl) {
  # Set up the bootstrap
  bootstrap_split <- bootstraps(train_tbl, times=1)  
  
  bootstrap_train_tbl <- analysis(get_rsplit(bootstrap_split, 1))
  
  # Set up the model, recipe and workflow
  poll_model <-  decision_tree(cost_complexity=0) |>
    set_mode("regression") |>
    set_engine("rpart")
  poll_recipe <- recipe(margin ~ day, data=bootstrap_train_tbl)
  poll_wflow <- workflow() |>
    add_recipe(poll_recipe) |>
    add_model(poll_model) 
  # Fit the worfklow using the training dataset  
  poll_fit <- fit(poll_wflow, bootstrap_train_tbl)
  augment(poll_fit, test_tbl) |>
    mutate(id=id)
}
```

We will be doing this process 20 times by making use of the `map_dfr` function and we will plot each of our bootstrapped models. Notice how every model is slightly different than the others.

```{r}
set.seed(12345)
bag_tbl <- map_dfr(1:20, create_bag_rtree, poll_train_tbl, poll_test_tbl)

ggplot(bag_tbl)+
    geom_point(aes(day,margin))+
    geom_step(aes(day,.pred), col="red")+
    facet_wrap(vars(id))
```

Finally we will average and plot the results across each tree and calculate our rmse, which is an improvement over our previous results

```{r}
bag_summary_tbl <- bag_tbl |>
  group_by(day) |>
  summarize(.pred = mean(.pred),
            margin = mean(margin)) 

ggplot(bag_summary_tbl)+
  geom_point(aes(day,margin))+
    geom_step(aes(day,.pred), col="red")

rmse(bag_summary_tbl, margin, .pred )
```

# Bagging models using `tidymodels()`

 We will be using the implementation of bagging from the `ranger` package. As before we will be creating a function `create_bag` that takes a training dataset and the number of trees that we are combining (`ntrees`).

```{r}
library(ranger)
create_bag <- function(train_tbl, ntrees) {
  # Set up the model, recipe and workflow
  poll_bag_model <-
  rand_forest(trees=ntrees) |>
  set_mode("regression") |>
  set_engine("ranger")

  poll_recipe <- recipe(margin ~ day, data=train_tbl)
  
  poll_wflow <- workflow() |>
    add_recipe(poll_recipe) |>
    add_model(poll_bag_model) 
  # Fit the worfklow using the training dataset  
  fit(poll_wflow, train_tbl)
}
```

First, let's look at the effect of adding trees one by one. Notice that as the number of trees becomes larger, our predicted value becomes less rugged.

```{r}
set.seed(12345)
for (i in seq(1,10, by=1)) {
  bag_model <- create_bag(poll_train_tbl, i)
  print(calc_rmse(bag_model, poll_test_tbl))
  print(plot_model(bag_model, polls_2008_tbl))
  Sys.sleep(1)
}
```

In bagging, usually the more the merrier, and around 100s of trees we start getting diminishing results. Let's settle for 100 trees and see the resulting model

```{r}
set.seed(12345)
bag_model <- create_bag(poll_train_tbl,1000)
calc_rmse(bag_model, poll_test_tbl)
plot_model(bag_model, polls_2008_tbl)
```


3. Use 10-fold cross validation and the following grid to identify the optimal value for `trees` using the one standard error rule.  What's the RMSE of the optimal model on the testing dataset?

```{r}
set.seed(12345)
poll_folds <- vfold_cv(poll_train_tbl, v = 10)
poll_grid <- grid_regular(trees(), levels = 10)
```

```{r}
bag_model <-
  rand_forest(trees=tune()) |>
  set_mode("regression") |>
  set_engine("ranger")
bag_recipe <- recipe(margin ~ day, data=poll_train_tbl)
bag_wflow <- workflow() |>
    add_recipe(bag_recipe) |>
    add_model(bag_model) 
```

```{r}
poll_res <- tune_grid(bag_wflow,resamples = poll_folds,grid = poll_grid)
show_best(poll_res)
autoplot(poll_res)
  # Select best penalty
(best_penalty <- select_by_one_std_err(poll_res,metric = "rmse", trees))
bag_final_wf <- finalize_workflow(bag_wflow,  best_penalty)

poll_final_fit <- fit(bag_final_wf, poll_train_tbl)

augment(poll_final_fit, poll_test_tbl) |>
  rmse(truth=margin, estimate=.pred)

plot_model(poll_final_fit, polls_2008_tbl)
```


